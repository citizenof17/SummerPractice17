\documentclass[bachelor, och, pract, times]{SCWorks}
% параметр - тип обучения - одно из значений:
%    spec     - специальность
%    bachelor - бакалавриат (по умолчанию)
%    master   - магистратура
% параметр - форма обучения - одно из значений:
%    och   - очное (по умолчанию)
%    zaoch - заочное
% параметр - тип работы - одно из значений:
%    referat    - реферат
%    coursework - курсовая работа (по умолчанию)
%    diploma    - дипломная работа
%    pract      - отчет по практике
% параметр - включение шрифта
%    times    - включение шрифта Times New Roman (если установлен)
%               по умолчанию выключен
\usepackage[T2A]{fontenc}
\usepackage[cp1251]{inputenc}
\usepackage{graphicx}

\usepackage[sort,compress]{cite}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{fancyvrb}
\usepackage{listings}
\usepackage{listingsutf8}
\usepackage{longtable}
\usepackage{array}
\usepackage[english,russian]{babel}


\usepackage[colorlinks=true]{hyperref}


\newcommand{\eqdef}{\stackrel {\rm def}{=}}

\newtheorem{lem}{Лемма}

\begin{document}

% Кафедра (в родительном падеже)
\chair{математической кибернетики и компьютерных наук}

% Тема работы
\title{Мосты и точки сочленения в графах.
Компоненты сильной связности. Конденсация графа}

% Курс
\course{2}

% Группа
\group{251}

% Факультет (в родительном падеже) (по умолчанию "факультета КНиИТ")
%\department{факультета КНиИТ}

% Специальность/направление код - наименование
\napravlenie{09.03.04 "--- Программная инженерия}
%\napravlenie{010500 "--- Математическое обеспечение и администрирование информационных систем}
%\napravlenie{230100 "--- Информатика и вычислительная техника}
%\napravlenie{231000 "--- Программная инженерия}
%\napravlenie{090301 "--- Компьютерная безопасность}

% Для студентки. Для работы студента следующая команда не нужна.
%\studenttitle{Студентки}

% Фамилия, имя, отчество в родительном падеже
\author{Соколкова Павла Вячеславовича}

% Заведующий кафедрой
\chtitle{к.ф.-м.н.} % степень, звание
\chname{С.~В.~Миронов}

%Научный руководитель (для реферата преподаватель проверяющий работу)
\satitle{доцент, к.~ф.-м.~н.} %должность, степень, звание
\saname{Ю.~Н.~Кондратова}

% Руководитель практики от организации (только для практики,
% для остальных типов работ не используется)
\patitle{руководитель ЦОПП}
\paname{М.~Р.~Мирзаянов}

% Семестр (только для практики, для остальных
% типов работ не используется)
\term{4}

% Наименование практики (только для практики, для остальных
% типов работ не используется)
\practtype{педагогическая}

% Продолжительность практики (количество недель) (только для практики,
% для остальных типов работ не используется)
\duration{2}

% Даты начала и окончания практики (только для практики, для остальных
% типов работ не используется)
\practStart{12.07.2016}
\practFinish{21.07.2016}

% Год выполнения отчета
\date{2017}

\maketitle

% Включение нумерации рисунков, формул и таблиц по разделам
% (по умолчанию - нумерация сквозная)
% (допускается оба вида нумерации)
%\secNumbering


\tableofcontents

% Раздел "Обозначения и сокращения". Может отсутствовать в работе


% Раздел "Определения". Может отсутствовать в работе
%\definitions

% Раздел "Определения, обозначения и сокращения". Может отсутствовать в работе.
% Если присутствует, то заменяет собой разделы "Обозначения и сокращения" и "Определения"
\defabbr
Граф "--- формальная модель различных дискретных систем внешнего мира.

Мост "--- такое ребро графа, удаление которого приводит к увеличению числа компонент связности.

Древесное ребро "--- ребро, образующее дерево поиска в глубину.

Обратное ребро "--- ребро, ведущее вверх по дереву.

Точка сочленения "--- это такая вершина, удаление которой и всех инцидентных ей рёбер увеличивает количество компонент связности.

Обход "--- алгоритм, который в некотором порядке посещает вершины графа.

DFS (\textit{Depth First Search}) "--- поиск в глубину.

BFS (\textit{Breadth First search}) "--- поиск в ширину.

Орграф "--- ориентированный граф.

% Раздел "Введение"
\intro
Целью практики является изучение алгоритмов, методов решения олимпиадных задач, освоение навыков преподавания нового материала, проведение разборов задач для других участников.

В результате прохождения практики должны быть отработаны навыки:

\begin{itemize}
    \item изучения нового материала;
    \item решения задач тематического характера;
    \item решения олимпиадных задач;
    \item проведения самостоятельного разбора задач для других участников;
    \item самостоятельная подготовка к соревнованиям;
    \item алгоритм поиска мостов в графе;
    \item алгоритм поиска точек сочленения в графе;
    \item выделение компонент сильной связности в ориентированном графе;
    \item конденсация графа;
\end{itemize}

\section{Теоретические сведения}
\subsection{Мосты в графах}

Мост "--- это ребро, которое не принадлежит какому"=либо простому циклу.
Мосты выбираются только из древесных рёбер.

Рассмотрим дерево $DFS$. Пусть $(u, v)$ -- древесное ребро. Вершина $u$ -- верхняя вершина, а вершина $v$ -- нижняя вершина, тогда $(u, v)$ не является мостом тогда и только тогда, когда найдётся обратное ребро, которое начинается в поддереве вершины $v$, а заканчивается в вершине $u$ или выше. Таким образом, для каждого древесного ребра необходимо проверить, есть ли подходящее обратное ребро.

В процессе поиска в глубину будем строить для вершин массив целочисленных пометок $fup$ (forward up), где
$fup[x] =$ наименьшая глубина такой вершины $y$, что вершина $y$ достижима из $x$ путём перехода $0$ или более раз вниз по дереву (forward) и не более $1$ раза по обратному ребру вверх (up).

Для лучшего понимания рассмотрим на рисунке \ref{pic_1}  некоторое дерево обхода в глубину и для каждой вершины укажем соответствующее ей значение пометки $fup$. Около каждой вершины указан её номер и через запятую значение $fup$ для этой вершины.

\begin{figure}[!ht]    \centering
    \includegraphics[scale=1.5]{graph1.png}
    \caption{Значения $fup$ вершин в дереве обхода в глубину}\label{pic_1}
\end{figure}

Ребро $(u, v)$ не является мостом, если найдётся обратное ребро из поддерева вершины $v$, которое ведёт строго выше вершины $v$. Иными словами, $(u, v)$ не мост тогда и только тогда, когда $fup[v] < глубина v$ в дереве обхода (аналогично  $fup[v] \leq глубина u$). На рисунке \ref{pic_3} представлена данная ситуация. Волнистой линией показан некоторый путь от корня дерева до вершины $u$. Вершина $y$ -- некоторая вершина, которая лежит выше $u$ (или совпадает с $u$), $x$ -- некоторая вершина в поддереве $v$ (может совпадать с $v$).
Поэтому в ходе работы алгоритма будем сравниваться значение пометки с глубиной $v$.

\begin{figure}[!ht]    \centering
    \includegraphics[scale=1]{graph3.png}
    \caption{Мост в дереве обхода}\label{pic_3}
\end{figure}

Ниже представлен псевдокод алгоритма для выделения мостов за $O(n + m)$, где $n$ -- количество вершин, $m$ -- количество рёбер. Массив $dep$ содержит информацию о реальной глубине вершины в дереве. Если вершина $v$ еще не встречалась в обходе, то $dep[v] = -1$.

\begin{Verbatim}[fontsize=\small, numbers=left, numbersep=2pt]
dfs(u, d, p)
	fup[u] = dep[u] = d;
	for (v : g[u])
		if (v == p) 
			continue;
		if (dep[v] >= 0) 
			fup[u] = min(fup[u], dep[v]);
		else
			dfs(v, d + 1, u);
			fup[u] = min(fup[u], fup[v]);
			if (fup[v] > d)
				(u, v) - мост;
\end{Verbatim}

\subsection{Точки сочленения в графе}

Точки сочленения также называю \textit{шарнирными вершинами}. Корень дерева $dfs$ является точкой сочленения тогда и только тогда, когда в дереве $dfs$ у него больше $1$ сына. Для всех остальных вершин $u$ достаточно наличие хотя бы одной вершины $v$, которая является потомком в дереве обхода, для которой $fup[v] \geq d$, где $d$ -- глубина вершины $u$.

Для лучшего понимания рассмотрим рисунок \ref{pic_2}, на котором  точки сочленения выделены красным цветом.

\begin{figure}[!ht]    \centering
    \includegraphics[scale=1]{graph2.png}
    \caption{Точки сочленения в неориентированном графе}\label{pic_2}
\end{figure}

Ниже представлен алгоритм для выделения точек сочленения в графе за $O(n + m)$, где $n$ -- количество вершин, $m$ -- количество рёбер. Как и для выделения мостов $fup[v]$ -- минимальная глубина, достижимая из $v$, $dep[u]$ -- глубина вершины $u$ (массив изначально инициализируется $-1$ для всех вершин).

\begin{Verbatim}[fontsize=\small, numbers=left, numbersep=2pt]
dfs(u, d, p)
	fup[u] = dep[u] = d;
	sons = 0;
	for (v : g[u])
		if (v == p) 
			continue;
		if (dep[v] >= 0) 
			fup[u] = min(fup[u], dep[v]);
		else
			sons++;
			dfs(v, d + 1, u);
			fup[u] = min(fup[u], fup[v]);
			if (u != p && fup[v] >= d)
				u - точка сочленения;
	if (u == p && sons > 1)
		u - точка сочленения;
\end{Verbatim}

\subsection{Компоненты сильной связности. Конденсация графа.}

Вершины $u$ и $v$ находятся в отношении сильной связности тогда и только тогда, когда из $u$ достижима $v$ и из $v$ достижима $u$. Иными словами, $u$ и $v$ принадлежат одному (не обязательно простому) циклу.

На рисунке \ref{pic_4} вершины, принадлежащие одной компоненте сильной связности, окрашены в один цвет.

\begin{figure}[!ht]    \centering
    \includegraphics[scale=1]{graph4.png}
    \caption{Компоненты сильной связности в орграфе}\label{pic_4}
\end{figure}

Отношение взаимной достижимости "--- это отношение эквивалентности:
\begin{itemize}
 \item Каждая вершина достижима из самой себя "--- рефлексивность;
 \item Если $u$ взаимно достижима с $v$, то $v$ взаимно достижима с $u$ "--- симметричность;
 \item Если $u$ взаимно достижима с $v$, а $v$ взаимно достижима с $w$, то $u$ взаимно достижима с $w$ "--- транзитивность;
\end{itemize}

Компонента сильной связности "--- это блок отношения взаимной достижимости. Иными словами, это максимальное по включению подмножество вершин, в котором любая пара вершин взаимно достижима. Иными словами, это максимальное по включению подмножество, в котором любые $2$ вершины принадлежат $1$ (не обязательно простому) циклу.

Рассмотрим орграф, который получается из заданного стягиванием каждого цикла в $1$ вершину (петли удаляются). Получившийся граф не содержит циклов и называется конденсацией.

На рисунке \ref{pic_5} представлена конденсация графа из рисунка \ref{pic_4}.

\begin{figure}[!ht]    \centering
    \includegraphics[scale=1]{graph5.png}
    \caption{Компоненты сильной связности в орграфе}\label{pic_5}
\end{figure}

\textbf{Задача:}

Выделить в орграфе компоненты сильной связности.

Если граф ациклический или все его циклы -- петли, то все компоненты сильной связности имеют размер $1$ (сами вершины).

Алгоритм выделения компонент связности и конденсации графа:

\begin{enumerate}
\item\label{it1}{Сделаем серию поисков в глубину и выпишем все вершины в порядке увеличения времени окончания их обработки;}
\item\label{it2}{Перевернём все дуги графа (рассмотрим транспонированный граф);}
\item{Отдельной серией поисков в глубину пройдём по всем вершинам транспонированного графа в порядке противоположном пункту \ref{it1};}
\item{Каждое отдельное дерево поиска в глубину из предыдущего пункта "--- компонента сильной связности.}
\end{enumerate}

Например, для графа, представленного на рисунке \ref{pic_6}, массив вершин для пункта \ref{it1} алгоритма будет следующим: $\{4, 5, 6, 1, 2, 3, 7\}$. При этом вершины $1, 5, 4$ принадлежат одной компоненте связности.

\begin{figure}[!ht]    \centering
    \includegraphics[scale=1]{graph6.png}
    \caption{Пример орграфа для пункта 1}\label{pic_6}
\end{figure}

А для пункта \ref{it2} граф будет выглядеть следующим образом -- рисунок \ref{pic_7}.

\begin{figure}[!ht]    \centering
    \includegraphics[scale=1]{graph7.png}
    \caption{Транспонированный граф}\label{pic_7}
\end{figure}

Этот алгоритм автоматически нумерует компоненты сильной связности в порядке топологической сортировки конденсации.

\textbf{Замечание:} в реализации проще на этапе построения (чтения графа) хранить как прямой (обычный), так и обратный (транспонированный) орграф. 

\section{Примеры задач и их решения}
\subsection{Мосты}

\textbf{Условие.} 

ограничение по времени на тест: 1 секунда

ограничение по памяти на тест: 256 мегабайт

ввод: стандартный ввод

вывод: стандартный вывод

Дан неориентированный граф. Требуется найти все мосты в нем.

\textbf{Входные данные.} Первая строка входных данных содержит два натуральных числа $n$ и $m$ "--- количества вершин и ребер графа соответственно ($1 \leq n \leq 20000$, $1 \leq m \leq 200000$).

Следующие $m$ строк содержат описание ребер по одному на строке. Ребро номер $i$ описывается двумя натуральными числами $b_i$, $e_i$ "--- номерами концов ребра ($1 \leq b_i, e_i \leq n$).

Граф не обязательно связный. Не содержит петель и кратных ребер.

\textbf{Выходные данные.} Первая строка выходных данных должна содержать одно натуральное число $b$ -- количество мостов в заданном графе. На следующей строке выведите $b$ целых чисел -- номера ребер, которые являются мостами, в возрастающем порядке. Ребра нумеруются с единицы в том порядке, в котором они заданы во входном файле.

\textbf{Решение.} Создадим массивы $g$, $fup$, $dep$. В массиве $g$ будем хранить граф списком смежности, в $fup$ будем хранить минимальную высоту в дереве обхода в глубину, которую можно достичь из $i$"=й вершины нулём или более спусками вниз и $1$ подъёмом по обратному ребру. Массив $dep$ будет содержать настоящую глубину вершин, изначально все элементы равны $-1$. Сделаем серию поисков в глубину. Пусть мы находимся в вершине $x$ и хотим перейти в вершину $y$. Если $y$ не является непосредственным предком $x$, из которого мы пришли в $x$, то, если ребро $(x, y)$ обратное 
($dep[y] \neq -1$), обновим значение $fup[x]$. В ином случае запустим обход в глубину из $y$. Обновим значение $fup[x]$. Если $fup[y] > d$, то ребро $(x, y)$ -- мост, внесём его номер в ответ.

Полный код программы приведен в приложении~\ref{A}.

\subsection{Точки сочленения}

\textbf{Условие.} 

ограничение по времени на тест: 1 секунда

ограничение по памяти на тест: 256 мегабайт

ввод: стандартный ввод

вывод: стандартный вывод

Дан неориентированный граф. Требуется найти все точки сочленения в нем.

\textbf{Входные данные.} 
Первая строка входного файла содержит два натуральных числа $n$ и $m$ "--- количества вершин и ребер графа соответственно ($1 \leq n \leq 20000$, $1 \leq m \leq 200000$).

Следующие $m$ строк содержат описание ребер по одному на строке. Ребро номер $i$ описывается двумя натуральными числами $b_i$, $e_i$ -- номерами концов ребра ($1 \leq b_i, e_i \leq n$).

\textbf{Выходные данные.} 
Первая строка выходного файла должна содержать одно натуральное число $b$ -- количество точек сочленения в заданном графе. На следующей строке выведите $b$ целых чисел -- номера вершин, которые являются точками сочленения, в возрастающем порядке.

\textbf{Решение.} Создадим массивы $g$, $fup$, $dep$. В массиве $g$ будем хранить граф списком смежности, в $fup$ будем хранить минимальную высоту в дереве обхода в глубину, которую можно достичь из $i$"=й вершины нулём или более спусками вниз и $1$ подъёмом по обратному ребру. Массив $dep$ будет содержать настоящую глубину вершин, изначально все элементы равны $-1$. Сделаем серию поисков в глубину. Для каждой вершины заведём переменную $sons$, которая изначально равно 0. Пусть мы находимся в вершине $x$ и хотим перейти в вершину $y$. Если $y$ не является непосредственным предком $x$, из которого мы пришли в $x$, то, если ребро $(x, y)$ обратное 
($dep[y] \neq -1$), обновим значение $fup[x]$. В ином случае увеличим значение переменной $sons$,  запустим обход в глубину из $y$. Обновим значение $fup[x]$. Если $fup[y] \geq d$ и $x$ не является корнем ($x \neq p$, где $p$ -- предок), то вершина $x$ -- точка сочленения, внесём её в ответ. После просмотра всех соседей точки $x$ проверим, является ли она корнем, и если является и имеет более 1 ребёнка (переменная $sons$), то внесём её в ответ.

Полный код программы приведен в приложении~\ref{B}.

\subsection{Конденсация графа (усложненная версия)}

\textbf{Условие.} 

ограничение по времени на тест: 1 секунда

ограничение по памяти на тест: 256 мегабайт

ввод: стандартный ввод

вывод: стандартный вывод

Вам задан связный ориентированный граф с $n$ вершинами и $m$ рёбрами. Петли и кратные ребра допускаются.

Такие пары вершин $u$, $v$, что из $u$ достижима $v$ и из $v$ достижима $u$ принадлежат одной компоненте сильной связности орграфа.

Очевидно, что если построить новый орграф у которого вершиной является компонента сильной связности старого, а дуга между парой вершин существует тогда и только тогда, когда она есть между какой-то парой вершин из соответствующих компонент сильной связности, то этот граф будет ациклическим. Такой граф называется конденсацией. Так как ациклический, его возможно топологически отсортировать. Сделайте это.

\textbf{Входные данные.} Граф задан во входном файле следующим образом: первая строка содержит числа $n$ и $m$ ($1 \leq n \leq 20000$, $1 \leq m \leq 200000$).

Каждая из следующих m строк содержат описание ребра -- два целых числа из диапазона от $1$ до $n$ -- номера начала и конца ребра.

\textbf{Выходные данные.} 
В первую строку выведите число $k$ "--- количество компонент сильной связности в заданном графе.

В следующую строку выведите $n$ чисел "--- для каждой вершины выведите номер компоненты сильной связности, которой принадлежит эта вершина. Компоненты сильной связности должны быть занумерованы таким образом, чтобы для любого ребра номер компоненты сильной связности его начала не превышал номера компоненты сильной связности его конца.

\textbf{Решение.} Создадим массивы $g$, $gr$, $used$, $fo$. В массиве $g$ будем хранить граф списком смежности, в $gr$ транспонированный граф, массив $used$ будет содержать информацию о рассмотренных вершинах, в $fo$ будет содержаться список вершин в порядке увеличения времени их обработки. Сделаем серию поисков в глубину. 
Перевернём массив $fo$, очистим массив $used$. Создадим переменную $clr$. Затем серией поисков в глубину в порядке нового массива $fo$ будем запускать обход из очередной вершины и красить её в цвет $clr$. После каждого обхода, увеличивая $clr$. Таким образом, каждая компонента связности будет окрашена в свой цвет, эта информация будет храниться в массиве $used$.  Так как алгоритм автоматически нумерует компоненты сильной связности в порядке топологической сортировки, осталось только вывести цвет каждой вершины из массива $used$.

Полный код программы приведен в приложении~\ref{C}.

% Раздел "Заключение"
\conclusion

В ходе прохождения практики были изучены и отработаны навыки по следующим темам:
\begin{itemize}
	\item графы;
	\item реализация программ;
	\item структуры данных;
	\item поиск в глубину, обход в ширину;
	\item поиск мостов в графе;
	\item поиск точек сочленения в графе;
	\item поиск компонент сильной связности в орграфе;
	\item конденсация графа;
	\item применение лекционного материала на практике;
	\item проведение разборов задач;
\end{itemize}

%Библиографический список, составленный вручную, без использования BibTeX
%
%\begin{thebibliography}{99}
%  \bibitem{Ione} Источник 1.
%  \bibitem{Itwo} Источник 2
%\end{thebibliography}

%Библиографический список, составленный с помощью BibTeX
%
%\bibliographystyle{gost780uv}
%\bibliography{thesis}

% Окончание основного документа и начало приложений
% Каждая последующая секция документа будет являться приложением

\appendix
\lstset{numbers = left, numberstyle = \tiny, language = C++, breaklines = true, basicstyle = \footnotesize}

\section{Программный код задачи <<Мосты>>}\label{A}
\lstinputlisting{A.cpp}

\section{Программный код задачи <<Точки сочленения>>}\label{B}
\lstinputlisting{B.cpp}

\section{Программный код задачи <<Конденсация графа (усложнённая версия)>>}\label{C}
\lstinputlisting{C.cpp}

\end{document}
